**Do you want to request a *feature* or report a *bug*?**
Request a feature

It is currently impossible to let React know that the output of a **functional component** is not affected by the current change. I think that it would be great to have a hook for enabling that capability. In other words: having SCU in functional components through a hook.

I'm aware of the existence of `React.memo` and I know that it is possible to accomplish the same thing by splitting the logic in 2 different functional components... as long as we enhance the "base" component with `React.memo`. However, I still think that the hook that I'm suggesting would be a pretty nice addition.

I guess that it's a good idea to show an example of a real case where this hook would be helpful. So, here we go:

I don't normally use the official react-redux bindings. Instead, I have my own version of the `connect` HOC which has a more limited and slightly different API, that better suits my needs. This makes my version slightly more performant and a lot lighter. Regardless of whether it is a good idea not to use the official react-redux bindings, this example illustrates the benefit of having the hook that I'm suggesting.

This is my current implementation:

```js
export default (fromStateProps_, fromActionProps, mapper) => {
  const isObject = typeof fromStateProps_ === 'object';
  const dependsOnProps =
    fromStateProps_ &&
    (isObject ? Object.values(fromStateProps_) : [fromStateProps_]).some(
      fn => fn.length !== 1
    );

  const fromStateProps = !fromStateProps_
    ? () => emptyObj
    : isObject
      ? (...args) => mapObj(fromStateProps_, fn => fn(...args))
      : fromStateProps_;

  return BaseComponent => {
    const ImpBaseComponent = memo(BaseComponent);
    let actionProps = fromActionProps ? null : emptyObj;
    let prevState;
    let prevStateProps;
    let prevResult;

    return props => {
      const {state, dispatch} = useContext(context);

      const stateProps =
        dependsOnProps || prevState !== state
          ? fromStateProps(state, props)
          : prevStateProps;

      if (!actionProps) {
        actionProps = mapObj(fromActionProps, fn => (...args) =>
          dispatch(fn(...args))
        );
      }

      if (prevStateProps && shallowCompare(stateProps, prevStateProps)) {
        return prevResult;
      }

      const finalProps = mapper
        ? mapper(stateProps, actionProps, props)
        : {...props, ...stateProps, ...actionProps};

      prevResult = <ImpBaseComponent {...finalProps} />;
      prevState = state;
      prevStateProps = stateProps;

      return prevResult;
    };
  };
};
```

It works great (for me). However, wouldn't it be awesome to implement it like this instead?

```js
export default (fromStateProps_, fromActionProps, mapper) => {
  const isObject = typeof fromStateProps_ === 'object';
  const dependsOnProps =
    fromStateProps_ &&
    (isObject ? Object.values(fromStateProps_) : [fromStateProps_]).some(
      fn => fn.length !== 1
    );

  const fromStateProps = !fromStateProps_
    ? () => emptyObj
    : isObject
      ? (...args) => mapObj(fromStateProps_, fn => fn(...args))
      : fromStateProps_;

  return BaseComponent => {
    const baseFn =
      BaseComponent instanceof Component
        ? p => <BaseComponent {...p} />
        : BaseComponent;
    let actionProps = fromActionProps ? null : emptyObj;
    let prevState;
    let prevStateProps;

    return props => {
      const cancelUpdate = useCancelUpdate();
      const {state, dispatch} = useContext(context);

      const stateProps =
        dependsOnProps || prevState !== state
          ? fromStateProps(state, props)
          : prevStateProps;

      if (!actionProps) {
        actionProps = mapObj(fromActionProps, fn => (...args) =>
          dispatch(fn(...args))
        );
      }

      if (prevStateProps && shallowCompare(stateProps, prevStateProps)) {
        return cancelUpdate();
      }

      prevState = state;
      prevStateProps = stateProps;

      const finalProps = mapper
        ? mapper(stateProps, actionProps, props)
        : {...props, ...stateProps, ...actionProps};

      return baseFn(finalProps);
    };
  };
};
```

How do you feel about having this new hook? Too weird? ðŸ˜„ 

Thanks,

Josep
